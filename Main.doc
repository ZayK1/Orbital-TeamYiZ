YiZ Planner README
üìã Table of Contents
Introduction & Project Vision
System Architecture & Design
2.1. High-Level Architecture Overview
2.2. Component Breakdown
2.2.1. Frontend (React Native Client)
2.2.2. Backend (Flask API Server)
2.2.3. Data Layer (MongoDB)
2.2.4. External Services (AI & Image APIs)
2.3. Detailed Data Flow
2.3.1. User Authentication Flow
2.3.2. AI Plan Generation Flow
Technology Stack
3.1. Frontend Stack (Mobile & Web)
3.2. Backend Stack (API Server)
3.3. AI & External Services Stack
3.4. Development & Operations Stack
3.5. Rationale for Technology Choices
Codebase Structure & Organization
4.1. Monorepo Philosophy
4.2. Frontend Directory Structure (/frontend)
4.3. Backend Directory Structure (/backend)
Backend Deep Dive
Frontend Deep Dive
API Reference Documentation
Database Schema & Data Modeling
8.1. users Collection
8.2. skills Collection
8.3. habits Collection
8.4. Indexing Strategy
Development Workflow & Quality Assurance
10.1. Version Control with Git
10.2. Code Quality & Linting
10.3. Testing Strategy
Troubleshooting Guide
Future Improvements & Roadmap
1. Introduction & Project Vision
üéØ Project Overview
YiZ Planner is a comprehensive cross-platform mobile application that revolutionizes how people launch new skills and build lasting habits. Our platform combines AI-powered coaching with personalized progress tracking to create adaptive learning experiences that prevent burnout and maintain optimal challenge levels throughout the user's journey.
üéØ Project Scope
One-sentence version: YiZ Planner is an AI-coached mobile platform where users can create custom skill/habit plans or generate AI plans, track their progress, and receive personalized coaching to prevent burnout while maintaining optimal learning momentum.
Detailed version: YiZ Planner addresses the critical gap between skill acquisition intention and successful habit formation by providing an intelligent, adaptive platform for both skill development and habit building. Users can either create their own custom learning plans and habit trackers or leverage our AI to generate personalized plans. The platform features an AI coach specialized for each skill/habit that provides real-time guidance, prevents burnout through difficulty adjustment, answers domain-specific questions, and delivers timely smart nudges and notifications. The system tracks progress comprehensively, adapts to user performance, and maintains engagement through intelligent coaching rather than generic reminders.
üßë‚Äçüéì Target Audience & Problem Motivation
Target Users
Skill Seekers wanting to launch new professional or personal skills with structured guidance
Habit Builders struggling to maintain consistency in building positive habits
Self-Improvers who start strong but burn out due to unrealistic expectations or lack of guidance
Busy Professionals needing adaptive learning that adjusts to their varying schedules and energy levels
Chronic Starters who repeatedly abandon learning goals due to lack of personalized support
Problem Statement 
The skill and habit development landscape faces critical challenges:
High Abandonment Rates: 92% of people abandon their learning goals within the first few months
Burnout from Poor Pacing: Generic plans don't adapt to individual capacity, leading to overwhelming difficulty spikes
Lack of Specialized Guidance: Users have skill-specific questions but no expert to ask
Generic Motivation Systems: One-size-fits-all notifications and reminders lose effectiveness quickly
Progress Tracking Gaps: Most apps track completion but not quality, difficulty adjustment, or learning momentum
Isolation in Learning: No coaching support during challenging phases when users are most likely to quit
Why This Problem Needs Solving
Traditional learning and habit-building apps treat users as data points rather than individuals with varying capacities, schedules, and learning styles. The missing piece is intelligent, adaptive coaching that understands both the domain expertise and the individual's journey that current AI models doesnt do. Without personalized guidance that prevents burnout and maintains optimal challenge, users are set up to fail. YiZ Planner solves this by providing AI coaches that understand both the skill being learned and the learner's current state, creating a sustainable path to mastery.
2. üèóÔ∏èSystem Architecture & Design
2.1. üó∫Ô∏è High-Level Architecture Overview
üîÑ Data Flow Sequence

YiZ Planner is built on a modern, decoupled client-server architecture. This design separates the user interface (frontend) from the business logic and data management (backend), promoting scalability, maintainability, and flexibility.
2.2.üß© Component Breakdown
2.2.1. Frontend (React Native Client)
The frontend is a single application built with React Native and Expo, responsible for all user-facing interactions. It is a "thin client" in that it does not contain complex business logic, which is instead delegated to the backend. Its primary responsibilities include rendering the UI, capturing user input, managing client-side state (like the current user session), and communicating with the backend API.
2.2.2. Backend (Flask API Server)
The backend, built with Python and the Flask framework, is the brain of the operation. It serves as a central hub that processes all requests from the frontend. Its key responsibilities include:
User Authentication: Securely managing user registration, login, and session verification via JWTs.
Business Logic: Handling the creation, retrieval, updating, and deletion (CRUD) of skills and habits.
AI Integration: Communicating with the OpenRouter API to generate learning plans.
Data Persistence: Interacting with the MongoDB database to store and retrieve all application data.
2.2.3.Data Layer (MongoDB)
We use MongoDB Atlas as our primary database. Its flexible, document-based (NoSQL) nature is perfectly suited for our application's data, which includes nested structures like the 30-day learning plans. It allows us to evolve our data schema easily as new features are developed.
2.2.4. External Services (AI & Image APIs)
To enrich the user experience and provide core functionality, the backend integrates with two key external services:
OpenRouter AI: This service is queried to generate the structured, 30-day JSON curriculum for new skills.
Unsplash API: Used to automatically fetch relevant, high-quality background images for skills and icons for habits, adding visual appeal without requiring user uploads.
2.3.‚û°Ô∏è Detailed Data Flow
2.3.1. User Authentication Flow
App Launch: The React Native app starts. The AuthContext immediately attempts to load a JWT from the device's AsyncStorage.
Token Verification: If a token is found, a request is sent to the backend's /auth/verify endpoint.
Backend Validation: The Flask server receives the token, decodes it, and validates its signature and expiration date.
Successful Response: If the token is valid, the server returns the associated user's data. The frontend AuthContext updates its state to "authenticated," storing the user data and navigating the user to the main RepositoryScreen.
Failed Response: If the token is invalid, expired, or not found, the server returns an error. The AuthContext sets its state to "unauthenticated," and the user is directed to the LoginScreen.
2.3.2. AI Plan Generation Flow
User Input: The user navigates to the AddSkillScreen and enters a skill name (e.g., "Learn JavaScript").
API Request: The frontend sends a POST request to the backend's /api/v1/plans/skills endpoint, including the skill name and the user's JWT for authorization.
Backend Processing: The Flask server receives the request and validates the user's token.
AI Service Call: The ai_service module on the backend constructs a carefully engineered prompt and sends a request to the OpenRouter AI API.
AI Response: OpenRouter processes the prompt and returns a structured JSON object containing a 30-day plan.
Image Service Call: Concurrently, the backend calls the Unsplash API with the skill name to find a suitable background image.
Data Persistence: The backend validates the plan from the AI, combines it with the image URL, and saves the complete skill document to the skills collection in MongoDB, linking it to the user_id.
Final Response: The server returns a 201 Created response to the frontend, containing the newly created skill object. The frontend then updates its state and navigates the user to view their new plan.
3. üíªTechnology Stack
3.1. Frontend Stack (Mobile & Web)
Category
Technology / Library
Version
Framework
React Native + Expo SDK
53
Language
JavaScript (JSX), TypeScript Support


Navigation
React Navigation


State
React Context + AsyncStorage


HTTP Client
Axios


Icons
Lucide React Native, @expo/vector-icons


UI Effects
expo-blur, expo-linear-gradient


SVG Support
react-native-svg



3.2. Backend Stack (API Server)
Category
Technology / Library
Version
Framework
Flask


Language
Python
3.11
Database Driver
PyMongo


Authentication
PyJWT, bcrypt
2.10, 4.3
CORS
Flask-CORS


Config Mgmt
python-dotenv


WSGI Server
Gunicorn



3.3. AI & External Services Stack
Category
Provider / Service
Model / Purpose
AI Plan Generation
OpenRouter API
DeepSeek-Chat-v3 (free tier)
Image Fetching
Unsplash API
aiohttp for async requests

3.4. Development & Operations Stack
Category
Tool
Purpose
Version Control
Git / GitHub
Source code management
Package Mgmt
npm (frontend), pip (backend)
Dependency management
Testing
Jest, Pytest
Unit & integration testing
Code Quality
ESLint, Prettier, Black, Flake8
Linting and code formatting
Web Hosting
Vercel
Deployment for web version
API Hosting
Render
Deployment for backend server
Mobile Build
Expo Application Services (EAS)
Building and distributing mobile apps

3.5. Rationale for Technology Choices
React Native + Expo: Chosen for its "write once, run anywhere" paradigm, allowing us to target iOS, Android, and Web with a single JavaScript codebase. Expo further simplifies development by managing native build configurations and providing a rich ecosystem of pre-vetted libraries.
Python + Flask: Python was selected for its robust AI/ML ecosystem and readability. Flask is a lightweight, "unopinionated" framework, giving us full control over the application's structure and library choices, making it ideal for a custom API service.
MongoDB: Its schema-less, document-oriented nature provides the flexibility needed for an application where data structures, like user plans, can be complex and evolve over time.
JWT for Authentication: JWTs are a stateless, secure, and industry-standard method for handling authentication in decoupled architectures, eliminating the need for server-side sessions.
Render / Vercel: This combination provides a best-in-class developer experience for deployment. Render is ideal for backend services (supporting Python/Gunicorn natively), while Vercel is optimized for hosting frontend applications (like our React Native for Web build).
4. üìÅCodebase Structure & Organization
4.1. Monorepo Philosophy
The project is organized in a monorepo structure with two top-level directories, frontend/ and backend/. This approach keeps all related code in a single repository, simplifying version control and making it easier to manage cross-cutting concerns between the client and server.
4.2. Frontend Directory Structure (/frontend)
The frontend codebase is organized to promote separation of concerns, reusability, and maintainability.
frontend/
‚îú‚îÄ‚îÄ üìÑ App.js              # Entry point, contains the root navigator and auth provider.
‚îú‚îÄ‚îÄ üìÑ .env                 # Local environment variables (API URL).
‚îú‚îÄ‚îÄ üìÅ src/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ api/             # Functions for interacting with the backend.
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ apiConfig.js # Configures the Axios instance with the base URL.
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ auth.js     # Contains functions for login, register, verify.
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ components/     # Reusable UI components (e.g., PlanCard, CustomButton).
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ context/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ AuthContext.js# Manages global authentication state and user data.
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ navigation/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ MainTabNavigator.jsx # Defines the primary app navigation structure.
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ screens/        # Top-level components representing a full screen.
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ LoginScreen.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÑ RepositoryScreen.jsx # The main dashboard.
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ constants/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÑ colors.js   # Centralized color palette for consistent styling.
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ hooks/          # Custom React hooks for reusable logic.
‚îî‚îÄ‚îÄ üìÅ assets/             # Static assets like images, fonts, and icons.


4.3. Backend Directory Structure (/backend)
The backend follows a modular structure inspired by industry best practices, separating logic by domain.
backend/
‚îú‚îÄ‚îÄ üìÑ app.py               # Flask app factory, configures and creates the app instance.
‚îú‚îÄ‚îÄ üìÑ config.py            # Loads and exposes configuration from environment variables.
‚îú‚îÄ‚îÄ üìÑ requirements.txt     # List of Python dependencies.
‚îú‚îÄ‚îÄ üìÑ Procfile             # For deployment on Render (defines the start command).
‚îú‚îÄ‚îÄ üìÅ api/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ v1/
‚îÇ       ‚îî‚îÄ‚îÄ üìÑ plans.py     # Blueprint for all plan-related routes (/api/v1/plans/*).
‚îú‚îÄ‚îÄ üìÅ auth/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ routes.py         # Blueprint for authentication routes (/auth/*).
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ models.py         # Defines the User data model and database interactions.
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ utils.py          # Helper functions for password hashing and JWT creation.
‚îú‚îÄ‚îÄ üìÅ models/
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ base.py           # (Future) Base model class with common DB helpers.
‚îú‚îÄ‚îÄ üìÅ repositories/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ habit_repository.py # Handles all database CRUD operations for habits.
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ skill_repository.py # Handles all database CRUD operations for skills.
‚îú‚îÄ‚îÄ üìÅ services/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ ai_service.py     # Logic for calling OpenRouter and parsing the response.
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ habit_service.py  # Higher-level business logic for habits (e.g., check-ins).
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ skill_service.py  # Higher-level business logic for skills.
‚îî‚îÄ‚îÄ üìÅ tests/                # Unit and integration tests for the backend.


5. ü§øBackend Deep Dive

5.1. Application Entry & Factory Pattern
The backend uses the "application factory" pattern in app.py. Instead of creating a global Flask app object, the create_app() function builds and configures the app instance at runtime. This approach has several advantages:
Testing: It allows for the creation of multiple app instances with different configurations for testing purposes.
Configuration: It centralizes the application setup, including CORS configuration and blueprint registration.
Scalability: It is the standard pattern for deploying Flask applications with WSGI servers like Gunicorn.
The Procfile for Render deployment simply points Gunicorn to this factory: web: gunicorn "backend.app:create_app()".











5.2. Authentication & Security Subsystem
Security is managed within the /auth module
5.2.1. Password Management with bcrypt
We never store passwords in plaintext. When a user registers, their password is run through the bcrypt hashing algorithm.


Using a high number of rounds (12) makes the hashing process computationally expensive, protecting against brute-force attacks.
5.2.2. JWT Generation and Verification
Upon successful login, a JSON Web Token (JWT) is generated. The token's payload contains essential, non-sensitive information.
A decorator is used to protect routes, automatically verifying the Authorization: Bearer <token> header on incoming requests.


5.3. AI Plan Generation Service (ai_service.py)


This service is the bridge to the OpenRouter API. It encapsulates all the logic for creating the prompt, making the API call, and processing the response.
Prompt Engineering: A detailed prompt is constructed to instruct the AI model to return a JSON object with a specific structure: an array of 30 objects, each with day, tasks, and resources keys. This is crucial for ensuring a predictable and parsable output.
API Call: It uses the requests or aiohttp library to send a POST request to the OpenRouter endpoint.
Error Handling & Validation: The service includes robust error handling to manage API failures, timeouts, or malformed responses from the AI. It attempts to parse the response as JSON and validates that the structure matches the required 30-day format before returning it to the main application logic.


üéØ Habit Check-in Flow


5.4. Business Logic: Services & Repositories
We employ a layered architecture to separate concerns:
Routes (plans.py): The outermost layer. It is responsible only for handling HTTP requests and responses, validating incoming data, and calling the appropriate service.
Services (skill_service.py): This layer contains the core business logic. For example, the SkillService orchestrates the process of creating a skill by calling the ai_service and the skill_repository.
Repositories (skill_repository.py): The innermost layer. Its sole responsibility is to communicate with the database. It contains all the PyMongo queries for creating, reading, updating, and deleting documents.
This separation makes the code easier to test, maintain, and reason about.

6.üåä Frontend Deep Dive



6.1. Navigation Architecture (React Navigation)
The app's navigation is powered by React Navigation and is designed to be intuitive and scalable.
RootNavigator (in App.js)
‚îú‚îÄ‚îÄ AuthProvider (Context)
‚îÇ   ‚îî‚îÄ‚îÄ if (user is authenticated)
‚îÇ       ‚îî‚îÄ‚îÄ MainTabNavigator
‚îÇ           ‚îú‚îÄ‚îÄ RepositoryStack (Initial Screen)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ RepositoryScreen (Dashboard)
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ AddSkillScreen
‚îÇ           ‚îÇ   ‚îú‚îÄ‚îÄ AddHabitScreen
‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ PlanDetailScreen
‚îÇ           ‚îú‚îÄ‚îÄ ExploreScreen
‚îÇ           ‚îú‚îÄ‚îÄ StatsScreen
‚îÇ           ‚îî‚îÄ‚îÄ ProfileScreen
‚îÇ   ‚îî‚îÄ‚îÄ else (user is not authenticated)
‚îÇ       ‚îî‚îÄ‚îÄ AuthStack
‚îÇ           ‚îú‚îÄ‚îÄ LoginScreen
‚îÇ           ‚îî‚îÄ‚îÄ RegisterScreen


A key feature is the custom bottom tab navigator, which remains hidden until a floating action button is pressed, providing a clean and focused UI. The "Repository" tab is a nested stack navigator, which allows users to drill down into detail screens (like adding a new skill) while remaining within the same main tab.
6.2. State Management Strategy
6.2.1. AuthContext for Global State
For global state, specifically user authentication status, we use React's built-in Context API. The AuthContext provider is wrapped around the entire application in App.js. It exposes:
user: The current user object, or null.
token: The user's JWT.
isLoading: A boolean to show a loading indicator during initial auth checks.
login(user, token): A function to set the user state and persist the token.
logout(): A function to clear the state and persisted data.
Any component in the tree can consume this context to access user data or trigger a logout.
6.2.2. AsyncStorage for Persistence
To keep users logged in between app sessions, the JWT is persisted to the device's local storage using AsyncStorage. When the app launches, the AuthContext reads from AsyncStorage. When the user logs in, the token is written to it. When they log out, the token is removed.
6.3. API Communication Layer
All backend communication is centralized within the /src/api directory. We use Axios as our HTTP client. A single Axios instance is created in apiConfig.js and configured with the API_BASE_URL from our environment variables. This instance is then used throughout the app for all API calls. This approach allows us to easily add interceptors for handling token attachment to headers or for global error handling in the future.
6.4. Key Screen Component Analysis
6.4.1. RepositoryScreen (Dashboard)
This is the main hub of the application. It's a complex component responsible for fetching and displaying all of a user's active skills and habits. It uses PlanCard components to render each item and features circular progress bars to provide an at-a-glance view of the user's daily progress.
6.4.2. ProfileScreen
This screen provides a comprehensive overview of the user's journey. It features:
A visually appealing gradient card displaying the user's name, current streak, and overall progress.
A grid of achievements and key statistics.
Toggle switches for application settings (e.g., Dark Mode, Notifications).
The "Log Out" button, which calls the logout function from the AuthContext.
6.4.3. AddSkillScreen & AddHabitScreen
These are form-based screens designed for simplicity and ease of use. They feature controlled components for all inputs, interactive elements for selecting things like difficulty or color, and clear call-to-action buttons that trigger the respective API calls to the backend.
6.4.4. MainTabNavigator (Custom Component)
This is a standout piece of UI engineering in the app. Instead of a standard tab bar, it uses a floating menu button. On press, a custom view, styled with expo-blur for a modern look, animates into view. The central + button triggers a secondary spring animation, presenting the "Add Skill" and "Add Habit" options, providing a fluid and engaging navigation experience.
7. üìöAPI Reference Documentation
7.1. General Conventions
Base URL: Loaded from environment variables.
Authentication: All protected routes require an Authorization: Bearer <JWT> header.
Response Format: All responses are in JSON format.
7.2. Authentication Endpoints (/auth)
7.2.1. POST /auth/register
Creates a new user account.
Request Body:
{
    "username": "string",
    "email": "string (unique)",
    "password": "string"
}


Success Response (201 Created):
{
    "message": "User created successfully",
    "token": "jwt_token",
    "user": { "_id": "...", "username": "...", "email": "..." }
}


Error Responses: 400 (Invalid data), 409 (Username or email already exists).
7.2.2. POST /auth/login
Logs in a user and returns a JWT.
Request Body:
{
    "identifier": "username_or_email",
    "password": "string"
}


Success Response (200 OK):
{
    "message": "Login successful",
    "token": "jwt_token",
    "user": { "_id": "...", "username": "...", "email": "..." }
}


Error Responses: 400 (Missing fields), 401 (Invalid credentials).
7.2.3. POST /auth/verify
Verifies the validity of an existing JWT.
Authorization: Bearer <token> required.
Success Response (200 OK):
{
    "valid": true,
    "user": { "_id": "...", "username": "...", "email": "..." }
}


Error Responses: 401 (Invalid or expired token).
7.3. Plan Generation Endpoints
7.3.1. POST /generate-plan
Note: This is a legacy or simplified endpoint. The primary creation logic is now within /api/v1/plans/skills.
Request Body: {"skill_name": "string"}
Success Response (200 OK): A structured 30-day plan JSON.
7.4. Skill & Habit Endpoints (/api/v1/plans)
7.4.1. POST /api/v1/plans/skills
Creates a new skill, including AI plan generation and image fetching.
Authorization: Bearer <token> required.
Request Body: {"skill_name": "string", "difficulty": "string"}
Success Response (201 Created): Returns the complete new skill object.
7.4.2. POST /api/v1/plans/habits
Creates a new habit.
Authorization: Bearer <token> required.
Request Body: {"title": "string", "category": "string", ...}
Success Response (201 Created): Returns the complete new habit object.
7.4.3. POST /api/v1/plans/habits/{id}/checkin
Records a completion for a habit for a specific day.
Authorization: Bearer <token> required.
Request Body (optional): {"date": "YYYY-MM-DD"} (defaults to today)
Success Response (200 OK): Returns the updated habit with new streak data.
7.4.4. GET /api/v1/plans/skills/{id}
Retrieves a single skill document by its ID.
Authorization: Bearer <token> required.
Success Response (200 OK): Returns the full skill object.
7.4.5. DELETE /api/v1/plans/*/{id}
Soft-deletes a skill or habit by changing its status to archived.
Authorization: Bearer <token> required.
Success Response (200 OK): {"message": "Document archived"}
7.5. System Health Endpoints
7.5.1. GET /health
A public endpoint to verify that the API is running.
Success Response (200 OK):
{
    "status": "healthy",
    "message": "YiZ Planner API is running",
    "timestamp": "ISO_date_string"
}


7.6. Standard Error Responses
Code
Status
Description
400
Bad Request
The request body is malformed or missing required fields.
401
Unauthorized
The provided JWT is missing, invalid, or expired.
403
Forbidden
The user is authenticated but not authorized to perform the action.
404
Not Found
The requested resource (e.g., a plan with a specific ID) does not exist.
409
Conflict
The request could not be completed due to a conflict (e.g., user already exists).
500
Internal Server Error
An unexpected error occurred on the server (e.g., database connection issue, AI service failure).

8. üíøDatabase Schema & Data Modeling
8.1. users Collection
Field
Type
Description
Index
_id
ObjectId
Unique identifier for the document.
Unique
username
String
User's unique public name.
Unique
email
String
User's unique email address.
Unique
password_hash
String
Hashed password using bcrypt.


created_at
ISODate
Timestamp of account creation.


updated_at
ISODate
Timestamp of the last update.


last_login
ISODate
Timestamp of the last successful login.



8.2. skills Collection
Field
Type
Description
_id
ObjectId
Unique identifier for the skill plan.
user_id
ObjectId
Foreign key referencing the users collection.
title
String
The user-provided title for the skill.
difficulty
String
'beginner', 'intermediate', or 'advanced'.
image_url
String
URL for a background image from Unsplash.
status
String
'active', 'completed', or 'archived'.
curriculum
Array
An array of 30 daily plan objects from the AI.
progress
Object
A nested object tracking completion metrics.
created_at
ISODate
Timestamp of creation.
updated_at
ISODate
Timestamp of the last update.

8.3. habits Collection
Field
Type
Description
_id
ObjectId
Unique identifier for the habit.
user_id
ObjectId
Foreign key referencing the users collection.
title
String
The name of the habit (e.g., "Drink Water").
category
String
User-defined category (e.g., "Health").
icon_url
String
URL for an illustrative icon from Unsplash.
color
String
Hex color code for UI theming.
pattern
Object
Defines the frequency and reminder times.
streaks
Object
Tracks current streak, longest streak, etc.
status
String
'active', 'paused', or 'archived'.
created_at
ISODate
Timestamp of creation.
updated_at
ISODate
Timestamp of the last update.

8.4. Indexing Strategy
To ensure fast query performance, the following indexes are automatically created by the application on its first run:
db.users.createIndex({ "username": 1 }, { unique: true })
db.users.createIndex({ "email": 1 }, { unique: true })
Future indexes will be added to optimize queries for fetching plans:
db.skills.createIndex({ "user_id": 1 })
db.habits.createIndex({ "user_id": 1 })

9. ‚úÖDevelopment Workflow & Quality Assurance
9.1. Version Control with Git
We follow a simplified Gitflow model:
main: This branch represents the stable, production-ready code.
develop: This is the primary development branch where all feature branches are merged.
Feature Branches: All new work must be done on a feature branch created from develop (e.g., feature/user-profiles).
Pull Requests (PRs): When a feature is complete, a pull request is created to merge the feature branch back into develop. PRs must be reviewed by at least one other team member before merging.
9.2. Code Quality & Linting
To maintain a clean and consistent codebase, we use a suite of automated tools:
Frontend: ESLint for identifying problematic patterns in JavaScript, and Prettier for enforcing a consistent code style.
Backend: Black for uncompromising code formatting, and Flake8 for checking style and quality.
These tools are configured to run automatically before commits to ensure all code adheres to our standards.
9.3. Testing Strategy
Our testing strategy is a work in progress and aims to cover multiple levels:
Unit Tests: (Jest for frontend, Pytest for backend) to test individual functions and components in isolation.
Integration Tests: To test the interaction between different parts of the system, such as a service and a repository, or an API endpoint and its underlying logic.
End-to-End (E2E) Tests: (Future) To simulate user behavior and test entire application flows from the UI to the database.
11. Troubleshooting Guide
CORS Errors: If the frontend can't connect to the backend, ensure the FRONTEND_URL in the backend's .env file and the origins list in app.py correctly match the URL of the running frontend client (including the Expo Go URL).
Invalid Token Errors (401): This can happen if the JWT_SECRET_KEY on the backend does not match the one used when previous tokens were issued, or if the token has expired. Try logging out and logging back in to get a fresh token.
Environment Variables Not Loading: For the frontend, ensure your file is named .env and you have restarted the Metro bundler (npx expo start -c) after making changes. For the backend, ensure the .env file is in the root of the /backend directory and you have restarted the Flask server.
AI Plan Generation Fails: Check that your OPENROUTER_API_KEY is correct and has not exceeded its usage limits. Check the backend server logs for any error messages from the AI service.
12. Future Improvements & Roadmap
Advanced AI Coaching: Move beyond plan generation to an interactive AI coach that can provide daily motivational messages, answer user questions about their tasks, and dynamically adjust the plan based on user feedback and progress.
Social & Community Features: Allow users to share their plans and progress with friends. Implement a "Discovery" screen where community-vetted plans can be browsed and adopted.
Gamification & Achievements: Introduce a more robust system of points, badges, and leaderboards to further enhance motivation and user engagement.
Enhanced Statistics & Visualizations: Provide users with detailed charts and graphs that visualize their consistency, progress over time, and most successful habits/skills.
Push Notifications: Implement smart, timely notifications for reminders and motivational nudges, moving beyond simple alerts.
Full TypeScript Migration: Incrementally migrate the entire frontend and backend codebase to TypeScript to improve code quality, maintainability, and developer experience.

