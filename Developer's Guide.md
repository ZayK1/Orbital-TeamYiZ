# 🚀 YiZ Planner - Complete Developer Guide



*Last Updated: June 12th 2025*



---



## 📋 Table of Contents



- [🎯 Project Overview](#-project-overview)

- [🛠️ Tech Stack](#️-tech-stack)

- [🏗️ Architecture Overview](#️-architecture-overview)

- [📁 Codebase Structure](#-codebase-structure)

- [🔧 Backend Deep Dive](#-backend-deep-dive)

- [📱 Frontend Deep Dive](#-frontend-deep-dive)

- [🔌 API Documentation](#-api-documentation)

- [🗄️ Database Schema](#️-database-schema)

- [⚙️ Setup & Installation](#️-setup--installation)

- [🔄 Development Workflow](#-development-workflow)

- [✨ Key Features Implementation](#-key-features-implementation)

- [🚀 Deployment Guide](#-deployment-guide)

- [🔧 Troubleshooting](#-troubleshooting)

- [🔮 Future Improvements](#-future-improvements)



---



## 🎯 Project Overview



**YiZ Planner** is a revolutionary cross-platform application that transforms skill acquisition through AI-powered 30-day learning plans. It combines cutting-edge mobile development with artificial intelligence to deliver personalized, structured learning experiences.



### ✨ Core Functionality



| Feature | Description |

|---------|-------------|

| 🔐 **Secure Authentication** | JWT-based auth with 7-day expiry & auto-refresh |

| 🤖 **AI Plan Generation** | Personalized 30-day learning plans via OpenRouter AI |

| 📊 **Plan Management** | View, track, and manage daily learning tasks |

| 📱 **Cross-Platform** | iOS, Android (Expo Go), and Web (Vercel) support |



### 🎯 Target Audience



- **Students** seeking structured learning paths

- **Professionals** wanting to upskill systematically

- **Self-learners** desiring AI-guided skill development

- **Anyone** looking to master new skills with structure



---



## 🛠️ Tech Stack

### 📱 Frontend (Mobile & Web)
```
Framework │ React Native + Expo SDK 53
Language │ JavaScript (JSX) with TypeScript support
Navigation │ React Navigation (Stack + Tab)
State │ React Context + AsyncStorage
HTTP Client │ Axios
Icons │ Lucide React Native
Build/Host │ Vercel (web), Expo Go/EAS (mobile)
```

### 🖥️ Backend (API Server)
```
Framework │ Python 3.11 + Flask
Database  │ MongoDB Atlas/Local with PyMongo
Authentication│ PyJWT 2.10 + bcrypt 4.3
CORS │ Flask-CORS
Config │ python-dotenv (local) / Render env-vars
Server │ Gunicorn with app factory pattern
HTTP Client │ httpx (async requests)
Async Support │ asgiref (async decorators)
```

### 🤖 AI Services
```
Provider │ OpenRouter API
Model │ deepseek/deepseek-r1-0528:free
Purpose │ Generate structured 30-day learning plans
```

### 🛠️ Development Tools
```
Version Control │ Git / GitHub
Package Mgmt │ npm + pip
Testing │ Jest, React-Testing-Library, Pytest
Code Quality │ ESLint, Prettier, Black, Flake8
```

---


## 🏗️ Architecture Overview




```mermaid
graph TB
A[React Native App] <-->|HTTPS/JSON| B[Flask API v1]
B <--> C[MongoDB Atlas]
B <--> D[OpenRouter AI]

subgraph "Frontend"
A
A1[AuthContext]
A2[AsyncStorage]
A3[Navigation]
end

subgraph "Backend Architecture"
B
B1["@require_auth Middleware"]
B2[Service Layer]
B3[Repository Pattern]
B4[Marshmallow Validation]
end

subgraph "Data Layer"
C
C1[Users Collection]
C2[Skills Collection]
C3[Habits Collection]
C4[Habit_Checkins Collection]
end

subgraph "Domain Model"
E[Skills Domain<br/>Finite, Curriculum-based]
F[Habits Domain<br/>Continuous, Streak-based]
end
```



### 🔄 Data Flow Sequence

1. **App Launch**: AuthContext loads JWT from AsyncStorage → `/auth/verify`
2. **Authentication**: Backend verifies JWT signature & expiry → returns user
3. **Skill Creation**: `/api/v1/plans/skills` → AI Service → structured curriculum
4. **Habit Creation**: `/api/v1/plans/habits` → Repository Layer → MongoDB
5. **Progress Tracking**: Skills use day completion, Habits use streak check-ins
6. **Persistence**: JWT & user data stored in AsyncStorage for offline access

### 🎯 Domain Architecture

**Skills Domain** (Finite Learning):
- 30-day structured curricula generated by AI
- Day-by-day completion tracking
- Curriculum-based progression with defined endpoints

**Habits Domain** (Continuous Practice):
- Ongoing behavioral patterns with customizable frequency
- Streak-based tracking and goal setting
- Check-in system for daily accountability

---



## 📁 Codebase Structure



### 📱 Frontend Structure

```

frontend/

├── 📄 App.js # Navigation root with auth switch

├── 📄 .env # Environment configuration

├── 📁 src/

│ ├── 📁 api/

│ │ ├── 📄 apiConfig.js # ENV-driven base URL config

│ │ └── 📄 auth.js # Auth API helpers

│ ├── 📁 context/

│ │ └── 📄 AuthContext.js # JWT persistence & state

│ ├── 📁 components/

│ │ ├── 📄 Button.js # Reusable button component

│ │ └── 📄 Input.js # Reusable input component

│ ├── 📁 screens/

│ │ ├── 📄 Login.jsx # Login interface

│ │ ├── 📄 Register.jsx # Registration interface

│ │ ├── 📄 Home.jsx # Main dashboard

│ │ ├── 📄 PlanIndex.jsx # Plan overview

│ │ ├── 📄 DayDetail.jsx # Daily task details

│ │ └── 📄 Profile.jsx # User profile

│ └── 📁 constants/

│ └── 📄 colors.js # App color palette

└── 📁 assets/ # Static resources

```



### 🖥️ Backend Structure

```
backend/
├── 📄 app.py                    # Flask app factory with g.db context
├── 📄 requirements.txt          # Python dependencies (+ marshmallow, httpx, asgiref)
├── 📄 .env                      # Environment variables
├── 📁 api/
│   └── 📁 v1/
│       └── 📄 plans.py          # RESTful API routes for Skills & Habits
├── 📁 auth/
│   ├── 📄 routes.py             # Auth endpoints + @require_auth decorator
│   ├── 📄 models.py             # User logic & DB operations (uses g.db)
│   └── 📄 utils.py              # Password hashing utilities
├── 📁 models/
│   └── 📄 base.py               # BasePlan, SkillPlan, HabitPlan data classes
├── 📁 repositories/
│   ├── 📄 skill_repository.py   # Database operations for skills
│   ├── 📄 habit_repository.py   # Database operations for habits
│   └── 📄 checkin_repository.py # Database operations for habit check-ins
├── 📁 schemas/
│   └── 📄 plan_schemas.py       # Marshmallow schemas for request validation
└── 📁 services/
    ├── 📄 ai_service.py         # OpenRouter AI integration
    ├── 📄 habit_service.py      # Business logic for habits domain
    └── 📄 skill_service.py      # Business logic for skills domain
```

---




## 🔧 Backend Deep Dive

### 🏗️ App Factory Pattern (`app.py`)

```python
def create_app():
    """Flask application factory with CORS configuration"""
    app = Flask(__name__)
    
    # CORS origins for cross-platform support
    origins = [
        FRONTEND_URL,
        "http://localhost:8081",  # Expo dev server
        "exp://192.168.0.116:8081"  # Expo Go
    ]
    
    CORS(app, origins=origins)
    
    # Register blueprints
    from backend.api.v1.plans import v1_plans_blueprint
    app.register_blueprint(v1_plans_blueprint, url_prefix='/api/v1/plans')
    
    # Set up database connection in application context
    @app.before_request
    def before_request():
        g.db = get_database_connection()
    
    return app

# Module-level export for Gunicorn
app = create_app()  # → gunicorn backend.app:app
```

The app factory pattern now includes:
- Registration of the `v1_plans_blueprint` for API routing
- Setup of `g.db` database connection for each request context
- Centralized CORS configuration for cross-platform support

### 🔐 Authentication System

#### 🔑 Security Features
- **bcrypt** hashing (12 rounds default)
- **JWT** payload: `{user_id, iat, exp(+7d)}`
- **Unique indexes** on username & email
- **Auto-created indexes** on first insert

#### 📊 User Model Operations

```python
class User:
    @staticmethod
    def create(username, email, password_hash):
        """Create new user with automatic timestamps"""
        user_data = {
            'username': username,
            'email': email,
            'password_hash': password_hash,
            'created_at': datetime.utcnow(),
            'updated_at': datetime.utcnow()
        }
        result = g.db.users.insert_one(user_data)
        return result.inserted_id
    
    @staticmethod
    def find_by_username_or_email(identifier):
        """Flexible login identifier lookup"""
        return g.db.users.find_one({
            '$or': [
                {'username': identifier},
                {'email': identifier}
            ]
        })
    
    @staticmethod
    def update_last_login(user_id):
        """Track user activity"""
        g.db.users.update_one(
            {'_id': ObjectId(user_id)},
            {'$set': {'last_login': datetime.utcnow()}}
        )
```

**Important Changes:**
- All database operations now use `g.db` instead of `current_app.db`
- The `@require_auth` decorator in `auth/routes.py` has been rewritten to be `async` to support async API routes
- Database connection is managed through Flask's application context (`g` object)

### 🤖 AI Plan Generation

```python
async def generate_30_day_plan(skill):
    """
    Generate structured 30-day learning plan using deepseek model
    
    Returns:
        list[dict]: [
            {
                "day": 1,
                "tasks": ["Task 1", "Task 2", "Task 3"],
                "resources": ["Resource 1", "Resource 2"]
            }
            # ... 30 days total
        ]
    """
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers={"Authorization": f"Bearer {OPENROUTER_API_KEY}"},
            json={
                "model": "deepseek/deepseek-r1-0528:free",
                "messages": [
                    {"role": "user", "content": f"Generate a 30-day learning plan for {skill}"}
                ]
            }
        )
        return response.json()
```

#### 🎯 Plan Structure Validation
- ✅ Ensures exactly 30 days
- ✅ Validates JSON response format
- ✅ Handles API errors gracefully
- ✅ Cleans and formats output
- ✅ Uses async httpx for non-blocking requests

---


## 📱 Frontend Deep Dive



### 🧭 Navigation Architecture



```

📱 App (AuthProvider)

├── 🔐 AuthStack

│ ├── LoginScreen

│ └── RegisterScreen

└── 🏠 MainTabNavigator

├── 📚 HomeStack (StackNavigator)

│ ├── HomeScreen

│ ├── PlanIndexScreen

│ └── DayDetailScreen

└── 👤 ProfileScreen

```



### 🔐 Authentication Context



```javascript

// Global authentication state management

const AuthContext = createContext();



// Key functions:

// • login(user, token) - Store in AsyncStorage + update state

// • logout() - Clear AsyncStorage + reset state

// • Auto-verification on app launch

// • Loading state management

```



### ⚙️ API Configuration



```javascript

// Environment-specific API endpoints

export const API_BASE_URL =

process.env.EXPO_PUBLIC_API_BASE_URL || // Mobile & web

process.env.REACT_APP_API_BASE_URL || // Web fallback

"http://192.168.0.116:8080"; // Development default

```



> 💡 **Pro Tip**: Metro shows `env: export ...` when environment variables are loaded



### 🎨 Screen Components



#### 🏠 HomeScreen Features

- Skill input interface with validation

- Plan generation with loading states

- Comprehensive error handling

- Sample plan loading for testing



#### 🔐 LoginScreen Features

- Form validation with real-time feedback

- AuthContext integration

- Smooth navigation transitions

- Error state management



---



### 🔌 API Documentation

### 🔐 Authentication

All API routes (except auth endpoints) require authentication via JWT token in the `Authorization` header:

```http
Authorization: Bearer <your_jwt_token>
```

Protected routes use the `@require_auth` decorator and return `401 Unauthorized` for invalid/missing tokens.

### 📊 Request Validation

Request bodies are validated using Marshmallow schemas. Invalid requests return `422 Unprocessable Entity` with detailed field-level errors:

```json
{
  "error": "Validation failed",
  "details": {
    "title": ["Field is required"],
    "difficulty": ["Must be one of: beginner, intermediate, advanced"]
  }
}
```

---

### 🔐 Authentication Endpoints

#### Register User
```http
POST /auth/register
Content-Type: application/json

{
  "username": "string",
  "email": "string", 
  "password": "string"
}
```

#### Login User
```http
POST /auth/login
Content-Type: application/json

{
  "identifier": "username_or_email",
  "password": "string"
}
```

#### Verify Token
```http
POST /auth/verify
Authorization: Bearer <token>
```

---

### 📚 Skills API (v1)

#### Create New Skill
```http
POST /api/v1/plans/skills
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "Master Python Programming",
  "skill_name": "Python Programming", 
  "difficulty": "intermediate"
}
```

**Response: 201 Created**
```json
{
  "message": "Skill plan created successfully",
  "skill": {
    "_id": "skill_id_here",
    "title": "Master Python Programming",
    "skill_name": "Python Programming",
    "difficulty": "intermediate",
    "curriculum": {
      "total_days": 30,
      "days": [
        {
          "day": 1,
          "tasks": [
            "Set up Python development environment",
            "Learn basic syntax and variables"
          ],
          "resources": [
            "Python.org official tutorial",
            "Codecademy Python course"
          ],
          "completed": false
        }
        // ... 29 more days
      ]
    },
    "progress": {
      "completed_days": 0,
      "completion_percentage": 0,
      "current_day": 1
    },
    "status": "active"
  }
}
```

#### Complete Skill Day
```http
PATCH /api/v1/plans/skills/{skill_id}/days/{day_number}/complete
Authorization: Bearer <token>
```

**Response: 200 OK**
```json
{
  "message": "Day marked as completed",
  "progress": {
    "completed_days": 5,
    "completion_percentage": 16.67,
    "current_day": 6
  }
}
```

---

### 🎯 Habits API (v1)

#### Create New Habit
```http
POST /api/v1/plans/habits
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "Morning Meditation",
  "category": "health",
  "pattern": {
    "frequency": "daily",
    "target_days": [1,2,3,4,5,6,7],
    "reminder_time": "07:00"
  },
  "goals": {
    "target_streak": 21,
    "weekly_target": 7,
    "monthly_target": 30
  }
}
```

**Response: 201 Created**
```json
{
  "message": "Habit created successfully",
  "habit": {
    "_id": "habit_id_here",
    "title": "Morning Meditation",
    "category": "health",
    "pattern": {
      "frequency": "daily",
      "target_days": [1,2,3,4,5,6,7],
      "reminder_time": "07:00"
    },
    "streaks": {
      "current_streak": 0,
      "longest_streak": 0,
      "total_completions": 0
    },
    "goals": {
      "target_streak": 21,
      "weekly_target": 7,
      "monthly_target": 30
    },
    "status": "active"
  }
}
```

#### Record Habit Check-in
```http
POST /api/v1/plans/habits/{habit_id}/checkin
Authorization: Bearer <token>
Content-Type: application/json

{
  "date": "2025-06-22",
  "completed": true,
  "notes": "Meditated for 10 minutes this morning"
}
```

**Response: 201 Created**
```json
{
  "message": "Check-in recorded successfully",
  "checkin": {
    "_id": "checkin_id_here",
    "date": "2025-06-22",
    "completed": true,
    "notes": "Meditated for 10 minutes this morning"
  },
  "updated_streaks": {
    "current_streak": 5,
    "longest_streak": 8,
    "total_completions": 23
  }
}
```

---

### 📋 Example cURL Requests

#### Create a Skill
```bash
curl -X POST https://your-api.onrender.com/api/v1/plans/skills \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Learn JavaScript Fundamentals",
    "skill_name": "JavaScript Programming",
    "difficulty": "beginner"
  }'
```

#### Create a Habit
```bash
curl -X POST https://your-api.onrender.com/api/v1/plans/habits \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Daily Reading",
    "category": "learning",
    "pattern": {
      "frequency": "daily",
      "target_days": [1,2,3,4,5,6,7],
      "reminder_time": "20:00"
    },
    "goals": {
      "target_streak": 30,
      "weekly_target": 7,
      "monthly_target": 30
    }
  }'
```

---




### 🗄️ Database Schema

### 👥 Users Collection

```javascript
{
  _id: ObjectId,
  username: String,        // unique index
  email: String,           // unique index
  password_hash: String,   // bcrypt hashed
  created_at: ISODate,     // auto-generated
  updated_at: ISODate,     // auto-updated
  last_login: ISODate      // tracked on login
}
```

### 📚 Skills Collection

```javascript
{
  _id: ObjectId,
  user_id: ObjectId,           // reference to users
  title: String,               // user-provided title
  skill_name: String,          // AI-generated skill focus
  difficulty: String,          // "beginner", "intermediate", "advanced"
  curriculum: {
    total_days: Number,        // always 30 for skills
    days: Array[{              // 30-day structured plan
      day: Number,
      tasks: Array[String],
      resources: Array[String],
      completed: Boolean,
      completed_at: ISODate
    }]
  },
  progress: {
    completed_days: Number,
    completion_percentage: Number,
    current_day: Number,
    last_accessed: ISODate
  },
  status: String,              // "active", "completed", "paused"
  created_at: ISODate,
  updated_at: ISODate
}
```

### 🎯 Habits Collection

```javascript
{
  _id: ObjectId,
  user_id: ObjectId,           // reference to users
  title: String,               // user-provided habit title
  category: String,            // "health", "productivity", "learning", etc.
  pattern: {
    frequency: String,         // "daily", "weekly", "custom"
    target_days: Array[Number], // [1,2,3,4,5] for weekdays
    reminder_time: String      // "09:00" format
  },
  streaks: {
    current_streak: Number,
    longest_streak: Number,
    total_completions: Number
  },
  goals: {
    target_streak: Number,     // user's streak goal
    weekly_target: Number,     // completions per week
    monthly_target: Number     // completions per month
  },
  status: String,              // "active", "paused", "archived"
  created_at: ISODate,
  updated_at: ISODate
}
```

### ✅ Habit Check-ins Collection

```javascript
{
  _id: ObjectId,
  habit_id: ObjectId,          // reference to habits
  user_id: ObjectId,           // reference to users (for performance)
  date: String,                // "YYYY-MM-DD" format
  completed: Boolean,
  notes: String,               // optional user notes
  created_at: ISODate,
  updated_at: ISODate
}
```

### 📊 Database Indexes

```javascript
// Users collection indexes
db.users.createIndex({ "username": 1 }, { unique: true })
db.users.createIndex({ "email": 1 }, { unique: true })

// Skills collection indexes
db.skills.createIndex({ "user_id": 1 })
db.skills.createIndex({ "user_id": 1, "status": 1 })
db.skills.createIndex({ "user_id": 1, "created_at": -1 })

// Habits collection indexes
db.habits.createIndex({ "user_id": 1 })
db.habits.createIndex({ "user_id": 1, "status": 1 })
db.habits.createIndex({ "user_id": 1, "category": 1 })

// Habit check-ins collection indexes
db.habit_checkins.createIndex({ "habit_id": 1, "date": 1 }, { unique: true })
db.habit_checkins.createIndex({ "user_id": 1, "date": -1 })
db.habit_checkins.createIndex({ "habit_id": 1, "date": -1 })
```

---




## ⚙️ Setup & Installation



### 📋 Prerequisites



- **Node.js** 16+

- **Python** 3.11+

- **MongoDB** (local or Atlas)

- **Expo CLI**

- **OpenRouter API** key



### 🖥️ Backend Setup

```bash
# 1. Navigate to backend directory
cd backend

# 2. Create virtual environment
python -m venv .venv

# 3. Activate virtual environment
# Windows:
.\.venv\Scripts\activate
# macOS/Linux:
source .venv/bin/activate

# 4. Install dependencies (now includes marshmallow, httpx, asgiref)
pip install -r requirements.txt

# 5. Configure environment
cp .env.sample .env
# Edit .env with your configuration:
# MONGO_URI=mongodb://localhost:27017/skillplan_db
# OPENROUTER_API_KEY=your_api_key_here
# JWT_SECRET_KEY=your_jwt_secret
# BCRYPT_ROUNDS=12
# FRONTEND_URL=http://localhost:8081

# 6. Run the server (CRITICAL: from project root, not backend folder)
cd ..  # Go back to project root (Orbital-TeamYiZ/)
python -m backend.app
# 🚀 Server running on http://localhost:8080
```

> **⚠️ Important Running Instructions:**
> - The server MUST be run from the project root directory using `python -m backend.app`
> - This is required because all imports are now absolute (e.g., `from backend.services.ai_service import AIService`)
> - Running `python app.py` from the backend folder will cause import errors

> **💡 IDE Configuration:**
> Configure your code editor (VS Code, PyCharm, etc.) to use the Python interpreter from `./backend/.venv/bin/python` (or `.venv\Scripts\python.exe` on Windows) to get correct linting and type-checking for the modular architecture.

---



### 📱 Frontend Setup



```bash

# 1. Navigate to frontend directory

cd frontend



# 2. Install dependencies

npm install



# 3. Configure environment

cp .env.sample .env

# Edit .env:

# EXPO_PUBLIC_API_BASE_URL=http://localhost:8080



# 4. Start development server

npx expo start -c



# 5. Run on your preferred platform:

# 📱 Scan QR code with Expo Go app

# 🤖 Press 'a' for Android emulator

# 🍎 Press 'i' for iOS simulator

# 🌐 Press 'w' for web browser

```



### 🔧 Development Environment Verification



```bash

# Test backend health

curl http://localhost:8080/health



# Test frontend connection

# Check Metro bundler output for environment variables

# Look for: "env: export EXPO_PUBLIC_API_BASE_URL=..."

```



---



## 🔄 Development Workflow

### 🌿 Git Workflow

```bash
# 1. Create feature branch
git checkout -b feature/amazing-new-feature

# 2. Make changes with quality checks
npm run lint # Frontend linting
npm run format # Code formatting
black . # Backend formatting
flake8 . # Backend linting

# 3. Test thoroughly
npm test # Frontend tests
pytest # Backend tests

# 4. Commit with semantic messages
git commit -m "feat: add user profile customization"

# 5. Push and create PR
git push origin feature/amazing-new-feature
# Create PR: feature/amazing-new-feature → develop → main
```

### 🔧 Adding New Features

#### 📱 Frontend Feature Development

```javascript
// 1. Create new screen
// src/screens/NewFeatureScreen.jsx
import React, { useState } from 'react';
import { View, Text } from 'react-native';

const NewFeatureScreen = () => {
    const [state, setState] = useState(null);
    
    return (
        <View>
            <Text>New Feature</Text>
        </View>
    );
};

export default NewFeatureScreen;

// 2. Add to navigation (App.js)
import NewFeatureScreen from './src/screens/NewFeatureScreen';

<Stack.Screen
    name="NewFeature"
    component={NewFeatureScreen}
    options={{ title: 'New Feature' }}
/>

// 3. Create API integration
// src/api/newFeature.js
import axios from 'axios';
import { API_BASE_URL } from './apiConfig';

export const newFeatureAPI = async (data) => {
    const response = await axios.post(`${API_BASE_URL}/new-feature`, data);
    return response.data;
};
```

#### 🖥️ Backend Feature Development (Service & Repository Pattern)

```python
# 1. Add new route in API blueprint (api/v1/plans.py)
from backend.services.user_service import UserService

@v1_plans_blueprint.route('/user-profile', methods=['POST'])
@require_auth
async def create_user_profile():
    """Create or update user profile - thin API layer"""
    try:
        data = request.get_json()
        user_id = g.current_user['user_id']
        
        # Call service layer for business logic
        profile = await UserService.create_profile(user_id, data)
        
        return jsonify({
            "message": "Profile created successfully",
            "profile": profile
        }), 201
        
    except ValidationError as e:
        return jsonify({"error": "Validation failed", "details": e.messages}), 422
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# 2. Add business logic in service (services/user_service.py)
from backend.repositories.user_repository import UserRepository

class UserService:
    @staticmethod
    async def create_profile(user_id, profile_data):
        """Business logic for profile creation"""
        # Validate business rules
        if not profile_data.get('display_name'):
            raise ValueError("Display name is required")
        
        # Process data according to business requirements
        processed_data = {
            'user_id': user_id,
            'display_name': profile_data['display_name'],
            'preferences': profile_data.get('preferences', {}),
            'created_at': datetime.utcnow(),
            'updated_at': datetime.utcnow()
        }
        
        # Call repository for data persistence
        profile_id = await UserRepository.create_profile(processed_data)
        
        # Return formatted response
        return await UserRepository.get_profile_by_id(profile_id)

# 3. Add database operations in repository (repositories/user_repository.py)
from bson import ObjectId

class UserRepository:
    @staticmethod
    async def create_profile(profile_data):
        """Pure database operation - no business logic"""
        result = g.db.user_profiles.insert_one(profile_data)
        return result.inserted_id
    
    @staticmethod
    async def get_profile_by_id(profile_id):
        """Retrieve profile by ID"""
        return g.db.user_profiles.find_one({'_id': ObjectId(profile_id)})
    
    @staticmethod
    async def update_profile(profile_id, update_data):
        """Update existing profile"""
        update_data['updated_at'] = datetime.utcnow()
        result = g.db.user_profiles.update_one(
            {'_id': ObjectId(profile_id)},
            {'$set': update_data}
        )
        return result.modified_count > 0
```

**Key Architecture Principles:**
- **API Routes**: Thin layer handling HTTP requests/responses, calling services
- **Services**: Business logic, validation, and coordination between repositories
- **Repositories**: Pure database operations with no business logic
- **Absolute Imports**: All imports use `from backend.` prefix for consistency



## ✨ Key Features Implementation

### 🔐 Authentication Flow

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant A as AuthContext
    participant B as Backend
    participant DB as Database

    U->>F: Enter credentials
    F->>B: POST /auth/login
    B->>DB: Query user
    DB->>B: User data
    B->>B: Verify password
    B->>F: {token, user}
    F->>A: login(user, token)
    A->>A: Store in AsyncStorage
    A->>F: Update global state
    F->>U: Navigate to main app
```

### 🤖 Plan Generation Process

```mermaid
sequenceDiagram
    participant U as User
    participant F as Frontend
    participant B as Backend
    participant AI as OpenRouter AI

    U->>F: Enter skill name
    F->>F: Show loading state
    F->>B: POST /api/v1/plans/skills
    B->>AI: Generate plan request
    AI->>B: AI-generated plan
    B->>B: Validate & format
    B->>F: Structured 30-day plan
    F->>F: Hide loading state
    F->>U: Display interactive plan
```

### 🏗️ Service Layer Architecture

The backend follows a clean **Service Layer** and **Repository Pattern** for better separation of concerns:

#### 🔧 Service Layer (`services/`)
- **Business Logic**: Domain-specific operations and validation
- **AI Integration**: Coordinates with OpenRouter for content generation using deepseek model
- **Cross-Repository Operations**: Handles complex operations spanning multiple data sources

```python
# Example: SkillService handles business logic
from backend.services.skill_service import SkillService

# Generate AI curriculum and save to database
skill = await SkillService.create_skill(
    user_id=user_id,
    title="Master React",
    skill_name="React Development", 
    difficulty="intermediate"
)
```

#### 🗄️ Repository Layer (`repositories/`)
- **Data Access**: Pure database operations without business logic
- **Query Optimization**: Efficient MongoDB queries and indexing
- **Error Handling**: Database-specific error handling and recovery

```python
# Example: SkillRepository handles data persistence
from backend.repositories.skill_repository import SkillRepository

# Pure database operation using g.db
skills = await SkillRepository.find_by_user_and_status(
    user_id=user_id, 
    status="active"
)
```

#### 📋 Schema Validation (`schemas/`)
- **Request Validation**: Marshmallow schemas for API input validation
- **Data Serialization**: Consistent API response formatting
- **Error Messages**: Detailed field-level validation errors

```python
# Example: Request validation with detailed errors
from backend.schemas.plan_schemas import CreateSkillSchema

schema = CreateSkillSchema()
try:
    data = schema.load(request.json)
except ValidationError as err:
    return jsonify({
        "error": "Validation failed",
        "details": err.messages
    }), 422
```

### 💾 State Persistence

```javascript
// AuthContext.js - JWT & User Data Persistence
const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);

    // Load persisted data on app launch
    useEffect(() => {
        loadPersistedAuth();
    }, []);

    const loadPersistedAuth = async () => {
        try {
            const token = await AsyncStorage.getItem('authToken');
            const userData = await AsyncStorage.getItem('userData');
            
            if (token && userData) {
                // Verify token is still valid
                const isValid = await authAPI.verifyToken(token);
                if (isValid) {
                    setUser(JSON.parse(userData));
                } else {
                    await clearAuthData();
                }
            }
        } catch (error) {
            console.error('Error loading auth data:', error);
        } finally {
            setLoading(false);
        }
    };

    const login = async (userData, token) => {
        try {
            await AsyncStorage.setItem('authToken', token);
            await AsyncStorage.setItem('userData', JSON.stringify(userData));
            setUser(userData);
        } catch (error) {
            console.error('Error saving auth data:', error);
        }
    };

    const logout = async () => {
        await clearAuthData();
        setUser(null);
    };

    return (
        <AuthContext.Provider value={{ user, login, logout, loading }}>
            {children}
        </AuthContext.Provider>
    );
};
```

### 🔧 Error Handling Strategy

#### 📱 Frontend Error Handling
```javascript
const handleAPIError = (error) => {
    if (error.response) {
        // Server responded with error status
        const message = error.response.data?.message || 'Server error occurred';
        setError(message);
        
        // Handle specific status codes
        if (error.response.status === 401) {
            // Token expired, redirect to login
            logout();
        }
    } else if (error.request) {
        // Network error
        setError('Network error. Please check your connection.');
    } else {
        // Other error
        setError('An unexpected error occurred.');
    }
    
    // Log error for debugging
    console.error('API Error:', error);
};
```

#### 🖥️ Backend Error Handling
```python
from flask import jsonify
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.errorhandler(Exception)
def handle_error(error):
    logger.error(f"Unhandled error: {str(error)}")
    
    # Don't expose internal errors in production
    if app.debug:
        error_message = str(error)
    else:
        error_message = "An internal server error occurred"
    
    return jsonify({
        "error": "Internal server error",
        "message": error_message
    }), 500

@app.errorhandler(400)
def handle_bad_request(error):
    return jsonify({
        "error": "Bad request",
        "message": "Invalid request data"
    }), 400
```

---



## 🚀 Deployment Guide



### 🌐 Frontend Deployment (Vercel)



#### 📋 Configuration



```json

// vercel.json

{

"builds": [

{

"src": "package.json",

"use": "@vercel/static-build",

"config": {

"distDir": "web-build"

}

}

],

"routes": [

{

"src": "/(.*)",

"dest": "/index.html"

}

]

}

```



#### 🚀 Deployment Steps



```bash

# 1. Install Vercel CLI

npm i -g vercel



# 2. Build for web

expo export:web



# 3. Deploy to Vercel

vercel --prod



# 4. Set environment variables in Vercel dashboard:

# EXPO_PUBLIC_API_BASE_URL=https://your-backend-url.onrender.com

```



### 🖥️ Backend Deployment (Render)



#### 📋 Configuration



```python

# Procfile

web: gunicorn backend.app:app --bind 0.0.0.0:$PORT --timeout 120

```



#### ⚙️ Environment Variables



```bash

# Set in Render dashboard:

MONGO_URI=mongodb+srv://user:pass@cluster.mongodb.net/skillplan_db

OPENROUTER_API_KEY=your_openrouter_key

JWT_SECRET_KEY=your_super_secret_jwt_key

FRONTEND_URL=https://your-frontend-url.vercel.app

BCRYPT_ROUNDS=12

FLASK_ENV=production

```



#### 🚀 Deployment Steps



1. **Connect Repository**: Link GitHub repo to Render

2. **Configure Build**:

- Build Command: `pip install -r requirements.txt`

- Start Command: `gunicorn backend.app:app --bind 0.0.0.0:$PORT`

3. **Set Environment Variables**: Add all required env vars

4. **Deploy**: Automatic deployment on git push



### 📱 Mobile App Distribution



#### 🍎 iOS (App Store)



```bash

# 1. Configure app.json for iOS

{

"expo": {

"ios": {

"bundleIdentifier": "com.yourcompany.yizplanner",

"buildNumber": "1.0.0"

}

}

}



# 2. Build for iOS

eas build --platform ios



# 3. Submit to App Store

eas submit --platform ios

```



#### 🤖 Android (Play Store)



```bash

# 1. Configure app.json for Android

{

"expo": {

"android": {

"package": "com.yourcompany.yizplanner",

"versionCode": 1

}

}

}



# 2. Build APK/AAB

eas build --platform android



# 3. Submit to Play Store

eas submit --platform android

```



---



## 🔧 Troubleshooting



### 📱 Common Frontend Issues



#### 🔄 Metro Bundler Issues

```bash

# Clear Metro cache

npx expo start --clear



# Reset npm cache

npm start -- --reset-cache



# Delete node_modules and reinstall

rm -rf node_modules package-lock.json

npm install

```



#### 🧭 Navigation Errors

```javascript

// Ensure proper navigation setup

import { NavigationContainer } from '@react-navigation/native';

import { createStackNavigator } from '@react-navigation/stack';



// Check screen imports

import HomeScreen from './src/screens/HomeScreen';



// Verify navigation usage

const navigation = useNavigation();

navigation.navigate('ScreenName', { param: 'value' });

```



#### 🌐 API Connection Issues

```javascript

// Debug API configuration

console.log('API Base URL:', API_BASE_URL);



// Test network connectivity

const testConnection = async () => {

try {

const response = await axios.get(`${API_BASE_URL}/health`);

console.log('✅ Backend connected:', response.data);

} catch (error) {

console.error('❌ Backend connection failed:', error.message);

}

};



// Check network permissions (app.json)

{

"expo": {

"permissions": ["INTERNET"]

}

}

```



### 🖥️ Common Backend Issues



#### 🗄️ MongoDB Connection

```python

# Test MongoDB connection

from pymongo import MongoClient

import os



try:

client = MongoClient(os.getenv('MONGO_URI'))

# Test connection

client.admin.command('ping')

print("✅ MongoDB connected successfully")

except Exception as e:

print(f"❌ MongoDB connection failed: {e}")

```



#### 🔗 CORS Issues

```python

# Ensure CORS is properly configured

from flask_cors import CORS



# Allow specific origins

CORS(app, origins=[

"http://localhost:8081", # Expo dev server

"https://yourapp.vercel.app", # Production frontend

"exp://192.168.0.116:8081" # Expo Go

])



# Debug CORS headers

@app.after_request

def after_request(response):

print(f"CORS headers: {response.headers}")

return response

```



#### 🤖 OpenRouter API Issues

```python

# Test OpenRouter API connection

import requests

import os



def test_openrouter_connection():

try:

response = requests.get(

"https://openrouter.ai/api/v1/models",

headers={"Authorization": f"Bearer {os.getenv('OPENROUTER_API_KEY')}"}

)

if response.status_code == 200:

print("✅ OpenRouter API connected")

else:

print(f"❌ OpenRouter API error: {response.status_code}")

except Exception as e:

print(f"❌ OpenRouter API connection failed: {e}")

```



### 🚀 Performance Issues



#### ⏱️ Plan Generation Timeout

```python

# Increase timeout in plan_service.py

response = requests.post(

url,

json=payload,

timeout=60, # Increased from 30 seconds

headers=headers

)

```



#### 📱 Frontend Rendering Performance

```javascript

// Optimize expensive components with React.memo

const ExpensiveComponent = React.memo(({ data }) => {

return <ComplexVisualization data={data} />;

});



// Optimize FlatList for large datasets

<FlatList

data={planDays}

renderItem={renderDayItem}

keyExtractor={(item) => item.day.toString()}

getItemLayout={(data, index) => ({

length: 80,

offset: 80 * index,

index

})}

removeClippedSubviews={true}

maxToRenderPerBatch={10}

windowSize={5}

/>

```



---


## ✨ Recently Implemented (June 2025)

### 🏗️ Major Architecture Refactoring

| 🎉 **Refactored to Service & Repository Architecture** |
|--------------------------------------------------------|
| **Service Layer**: All business logic moved to `/services/*.py` files that coordinate between repositories and handle domain-specific operations |
| **Repository Pattern**: Pure database operations isolated in `/repositories/*.py` files with no business logic |
| **Thin API Routes**: `/api/v1/plans.py` routes now only handle HTTP requests/responses and delegate to services |
| **Dataclass Models**: Implemented structured data models in `/models/base.py` using Python dataclasses |

### 🚀 Async API Endpoints

| Feature | Description |
|---------|-------------|
| **Async Route Handlers** | Primary Flask API routes in `plans.py` converted to `async def` for better performance |
| **Async Auth Decorator** | `@require_auth` decorator rewritten to support async routes using `asgiref` library |
| **Async AI Integration** | AI service now uses `httpx` for async HTTP requests to OpenRouter API |

### 🔧 Enhanced Development Infrastructure

| Feature | Description |
|---------|-------------|
| **Absolute Module Imports** | All backend imports standardized to absolute paths (`from backend.services.skill_service import ...`) |
| **Database Context Management** | Database connection now managed via Flask's `g.db` object instead of `current_app` proxy |
| **Updated Dependencies** | Added `httpx`, `asgiref`, and `marshmallow` to requirements for async support and validation |
| **Improved AI Model** | Switched to `deepseek/deepseek-r1-0528:free` model for better plan generation |

### ⚡ Key Enabling Changes

- **Async Support**: `asgiref` dependency enables async decorators in Flask
- **HTTP Client**: `httpx` provides async HTTP client for AI API calls
- **Module Structure**: Absolute imports improve code organization and IDE support
- **Database Access**: `g.db` pattern provides cleaner database connection management

---

## 🔮 Future Improvements

### 🎯 Planned Features

| Priority | Feature | Description | Timeline |
|----------|---------|-------------|----------|
| 🔴 High | **Progress Tracking** | Mark daily tasks as complete | June |
| 🟠 Medium | **Fetch & Manage Plans** | Implement API endpoints to list all user plans (`GET /api/v1/plans`), retrieve a single plan (`GET /api/v1/plans/{plan_id}`), and delete a plan (`DELETE /api/v1/plans/{plan_id}`) | June |
| 🟡 Medium | **Push Notifications** | Daily learning-reminder notifications via Expo | June |
| 🟢 Low | **Gamification** | Achievements & learning streak badges | June |

## 📑 Environment-Variable Reference

| Key | Where Used | Local Example | Prod Example |
|-----|-----------|---------------|--------------|
| `MONGO_URI` | Backend | `mongodb://localhost:27017/skillplan_db` | Atlas SRV string |
| `JWT_SECRET_KEY` | Backend | `dev-secret-change` | 64-char hex |
| `OPENROUTER_API_KEY` | Backend | `sk-…` | Same |
| `FRONTEND_URL` | Backend CORS | `http://localhost:8081` | `https://<vercel-url>` |
| `BCRYPT_ROUNDS` | Backend | `12` | `12` |
| `EXPO_PUBLIC_API_BASE_URL` | Frontend | `http://192.168.0.116:8080` | `https://<render-url>` |

---

### 🧪 Testing Cheat-Sheet

```bash
# 👉 Backend (Updated Commands)
cd backend && .venv\Scripts\activate

# Run from project root (IMPORTANT!)
cd .. 
python -m backend.app

# Test endpoints
curl http://localhost:8080/health
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","email":"test@example.com","password":"secret123"}'

# Test v1 API endpoints (requires auth token)
curl -X POST http://localhost:8080/api/v1/plans/skills \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"title":"Learn Python","skill_name":"Python Programming","difficulty":"beginner"}'

# 👉 Frontend  
cd frontend
npm test                 # jest / RTL
npx expo start -c        # clear Metro cache + env load

# Verify persistence:
# 1. Register & login in Expo Go
# 2. Create skills and habits
# 3. Close Expo Go (swipe-away) 
# 4. Re-open → app should show your created plans
```

## 📞 Support & Resources

### Documentation Links
- [React Native Docs](https://reactnative.dev/docs/getting-started)
- [Expo Documentation](https://docs.expo.dev/)
- [Flask Documentation](https://flask.palletsprojects.com/)
- [MongoDB Documentation](https://docs.mongodb.com/)
- [OpenRouter API Docs](https://openrouter.ai/docs)

### Development Communities
- [React Native Community](https://github.com/react-native-community)
- [Expo Forums](https://forums.expo.dev/)
- [Flask Discord](https://discord.gg/flask)

### Debugging Tools
- **Frontend**: React Native Debugger, Flipper
- **Backend**: Flask Debug Mode, MongoDB Compass
- **API Testing**: Postman, Insomnia

---

## 📄 License & Contributing

### Development Guidelines
1. Follow established code style and patterns
2. Write comprehensive tests for new features
3. Update documentation for API changes
4. Use semantic commit messages
5. Create feature branches for new development

### Code Review Process
1. Create feature branch from main
2. Implement feature with tests
3. Submit pull request with description
4. Address review feedback
5. Merge after approval

---

> **Keep this guide living!**  When you merge a feature branch that affects the API, database, or deployment flow, append a note here.
> *This guide serves as a living document and should be updated as the project evolves. For questions or clarifications, please reach out to the development team.*